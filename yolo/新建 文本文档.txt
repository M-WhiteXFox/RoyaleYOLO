import cv2
import json
import os
import tkinter as tk
from tkinter import ttk, messagebox, simpledialog, filedialog
from PIL import Image, ImageTk
from ultralytics import YOLO


class YoloAnnotator:
    def __init__(self, root):
        self.root = root
        self.root.title("YOLO 视频标注工具")
        self.root.geometry("1400x950")

        # ========== 内部状态变量 ==========
        self.config_file = "config.json"

        self.video_path = tk.StringVar()
        self.model_path = tk.StringVar()
        self.output_dir = tk.StringVar()
        self.conf_threshold = tk.DoubleVar(value=0.5)
        self.img_size = tk.IntVar(value=640)
        self.frame_interval = tk.IntVar(value=5)

        self.load_config()  # 优先加载配置

        self.cap = None
        self.model = None
        self.class_names = []
        self.history = []  # 存储处理过的帧号
        self.current_frame_num = 0
        self.current_frame_img = None
        self.detections = []  # 存储当前帧的标注信息
        self.selected_detection_id = None
        self.drawing = False
        self.add_box_mode = False
        self.new_box_start_pos = None
        self.temp_box_id = None

        # ========== 初始化 GUI ==========
        self.setup_gui()
        self.bind_events()
        self.root.protocol("WM_DELETE_WINDOW", self.on_closing)  # 窗口关闭时保存配置

    def load_config(self):
        try:
            if os.path.exists(self.config_file):
                with open(self.config_file, 'r', encoding='utf-8') as f:
                    config = json.load(f)
                    self.video_path.set(config.get("video_path", ""))
                    self.model_path.set(config.get("model_path", ""))
                    self.output_dir.set(config.get("output_dir", ""))
                    self.conf_threshold.set(config.get("conf_threshold", 0.5))
                    self.img_size.set(config.get("img_size", 640))
                    self.frame_interval.set(config.get("frame_interval", 5))
            else:
                self.create_default_config()
        except (json.JSONDecodeError, FileNotFoundError):
            self.create_default_config()

    def save_config(self):
        # 从UI entry获取最新的参数值
        try:
            self.frame_interval.set(int(self.interval_entry.get()))
            self.conf_threshold.set(float(self.conf_entry.get()))
            self.img_size.set(int(self.img_size_entry.get()))
        except (ValueError, AttributeError):
            pass  # 如果UI未初始化或值无效，则保留原值

        config = {
            "video_path": self.video_path.get(),
            "model_path": self.model_path.get(),
            "output_dir": self.output_dir.get(),
            "conf_threshold": self.conf_threshold.get(),
            "img_size": self.img_size.get(),
            "frame_interval": self.frame_interval.get()
        }
        with open(self.config_file, 'w', encoding='utf-8') as f:
            json.dump(config, f, indent=4)

    def create_default_config(self):
        default_config = {
            "video_path": r"E:\hszz\yolo\video\gzx_1.mp4",
            "model_path": r"E:\hszz\yolo\model\train_2\weights\best.pt",
            "output_dir": r"E:\hszz\yolo\labelme_dataset",
            "conf_threshold": 0.5,
            "img_size": 640,
            "frame_interval": 5
        }
        self.video_path.set(default_config["video_path"])
        self.model_path.set(default_config["model_path"])
        self.output_dir.set(default_config["output_dir"])
        self.conf_threshold.set(default_config["conf_threshold"])
        self.img_size.set(default_config["img_size"])
        self.frame_interval.set(default_config["frame_interval"])

        with open(self.config_file, 'w', encoding='utf-8') as f:
            json.dump(default_config, f, indent=4)

    def on_closing(self):
        self.save_config()
        self.root.destroy()

    def setup_gui(self):
        # 主框架
        main_frame = ttk.Frame(self.root, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)

        # ---------- 顶部配置区域 ----------
        config_frame = ttk.LabelFrame(main_frame, text="配置", padding="10")
        config_frame.pack(fill=tk.X, expand=False)
        config_frame.grid_columnconfigure(1, weight=1)

        ttk.Label(config_frame, text="视频文件:").grid(row=0, column=0, sticky="w", padx=5, pady=2)
        ttk.Entry(config_frame, textvariable=self.video_path, state="readonly").grid(row=0, column=1, sticky="we")
        ttk.Button(config_frame, text="选择...", command=self.select_video).grid(row=0, column=2, padx=5)

        ttk.Label(config_frame, text="模型文件:").grid(row=1, column=0, sticky="w", padx=5, pady=2)
        ttk.Entry(config_frame, textvariable=self.model_path, state="readonly").grid(row=1, column=1, sticky="we")
        ttk.Button(config_frame, text="选择...", command=self.select_model).grid(row=1, column=2, padx=5)

        ttk.Label(config_frame, text="输出目录:").grid(row=2, column=0, sticky="w", padx=5, pady=2)
        ttk.Entry(config_frame, textvariable=self.output_dir, state="readonly").grid(row=2, column=1, sticky="we")
        ttk.Button(config_frame, text="选择...", command=self.select_output_dir).grid(row=2, column=2, padx=5)

        # 加载按钮和参数配置
        action_frame = ttk.Frame(config_frame)
        action_frame.grid(row=3, column=0, columnspan=3, pady=5)
        self.load_button = ttk.Button(action_frame, text="加载模型和视频", command=self.load_assets)
        self.load_button.pack(side=tk.LEFT, padx=5)
        self.check_paths()

        self.repredict_btn = ttk.Button(action_frame, text="重新预测", command=self.re_predict_frame, state="disabled")
        self.repredict_btn.pack(side=tk.LEFT, padx=5)

        ttk.Label(action_frame, text="抽帧间隔:").pack(side=tk.LEFT, padx=(20, 5))
        self.interval_entry = ttk.Entry(action_frame, width=5, textvariable=self.frame_interval)
        self.interval_entry.pack(side=tk.LEFT)

        # 置信度滑块和输入框
        conf_frame = ttk.Frame(action_frame)
        ttk.Label(conf_frame, text="置信度阈值:").pack(side=tk.LEFT)
        self.conf_slider = ttk.Scale(conf_frame, from_=0.0, to=1.0, variable=self.conf_threshold, orient=tk.HORIZONTAL)
        self.conf_slider.pack(side=tk.LEFT, padx=(5, 0))
        self.conf_entry = ttk.Entry(conf_frame, width=5, textvariable=self.conf_threshold)
        self.conf_entry.pack(side=tk.LEFT)
        conf_frame.pack(side=tk.LEFT, padx=(20, 5))

        ttk.Label(action_frame, text="图像尺寸:").pack(side=tk.LEFT, padx=(20, 5))
        self.img_size_entry = ttk.Entry(action_frame, width=5, textvariable=self.img_size)
        self.img_size_entry.pack(side=tk.LEFT)

        # ---------- 中心工作区域 ----------
        workspace = ttk.PanedWindow(main_frame, orient=tk.HORIZONTAL)
        workspace.pack(fill=tk.BOTH, expand=True, pady=10)

        # ... (中心工作区域GUI代码不变) ...
        # 左侧原图画布
        left_pane = ttk.Frame(workspace)
        ttk.Label(left_pane, text="原图", font=("Arial", 12)).pack()
        self.orig_canvas = tk.Canvas(left_pane, bg="lightgray")
        self.orig_canvas.pack(fill=tk.BOTH, expand=True)
        workspace.add(left_pane, weight=1)

        # 右侧检测和编辑画布
        right_pane = ttk.PanedWindow(workspace, orient=tk.VERTICAL)

        canvas_frame = ttk.Frame(right_pane)
        ttk.Label(canvas_frame, text="检测结果 (可编辑)", font=("Arial", 12)).pack()
        self.detect_canvas = tk.Canvas(canvas_frame, bg="lightgray", cursor="crosshair")
        self.detect_canvas.pack(fill=tk.BOTH, expand=True)
        right_pane.add(canvas_frame, weight=3)

        # 右下侧标注列表和编辑按钮
        edit_area = ttk.Frame(right_pane)
        edit_area_frame = ttk.LabelFrame(edit_area, text="标注列表与操作", padding=5)
        edit_area_frame.pack(fill=tk.BOTH, expand=True)

        self.detection_list = tk.Listbox(edit_area_frame)
        self.detection_list.pack(fill=tk.BOTH, expand=True, side=tk.LEFT, padx=5)

        edit_btn_frame = ttk.Frame(edit_area_frame)
        self.add_box_btn = ttk.Button(edit_btn_frame, text="添加新框", command=self.toggle_add_box_mode,
                                      state="disabled")
        self.add_box_btn.pack(pady=5, fill=tk.X)
        self.delete_btn = ttk.Button(edit_btn_frame, text="删除选中", command=self.delete_selected, state="disabled")
        self.delete_btn.pack(pady=5, fill=tk.X)
        self.clear_btn = ttk.Button(edit_btn_frame, text="全部清除", command=self.clear_all_detections,
                                    state="disabled")
        self.clear_btn.pack(pady=5, fill=tk.X)
        edit_btn_frame.pack(side=tk.LEFT, fill=tk.Y, padx=5)

        right_pane.add(edit_area, weight=1)
        workspace.add(right_pane, weight=1)

        # ---------- 底部导航和状态栏 ----------
        bottom_frame = ttk.Frame(main_frame)
        bottom_frame.pack(fill=tk.X, expand=False)

        self.prev_btn = ttk.Button(bottom_frame, text="上一张", command=lambda: self.navigate_frames(-1),
                                   state="disabled")
        self.prev_btn.pack(side=tk.LEFT, padx=5)
        self.next_btn = ttk.Button(bottom_frame, text="保存并下一张",
                                   command=lambda: self.navigate_frames(1, save=True), state="disabled")
        self.next_btn.pack(side=tk.LEFT, padx=5)
        self.skip_btn = ttk.Button(bottom_frame, text="忽略并下一张",
                                   command=lambda: self.navigate_frames(1, save=False), state="disabled")
        self.skip_btn.pack(side=tk.LEFT, padx=5)

        self.status_label = ttk.Label(bottom_frame, text="请先配置并加载...", anchor="w")
        self.status_label.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=10)

    # --- 事件绑定 ---
    def bind_events(self):
        self.detect_canvas.bind("<ButtonPress-1>", self.on_press)
        self.detect_canvas.bind("<B1-Motion>", self.on_drag)
        self.detect_canvas.bind("<ButtonRelease-1>", self.on_release)
        self.detect_canvas.bind("<Button-3>", self.on_right_press)  # 右键单击
        self.detection_list.bind("<<ListboxSelect>>", self.on_list_select)
        self.root.bind("<Delete>", self.delete_selected)
        self.root.bind("<Escape>", self.cancel_add_mode)

    # --- 文件/目录选择 ---
    def select_video(self):
        path = filedialog.askopenfilename(title="选择视频文件",
                                          filetypes=[("MP4 files", "*.mp4"), ("All files", "*.*")])
        if path:
            self.video_path.set(path)
            self.check_paths()
            self.save_config()

    def select_model(self):
        path = filedialog.askopenfilename(title="选择YOLO模型",
                                          filetypes=[("PyTorch Model", "*.pt"), ("All files", "*.*")])
        if path:
            self.model_path.set(path)
            self.check_paths()
            self.save_config()

    def select_output_dir(self):
        path = filedialog.askdirectory(title="选择输出目录")
        if path:
            self.output_dir.set(path)
            self.check_paths()
            self.save_config()

    def check_paths(self):
        if self.video_path.get() and self.model_path.get() and self.output_dir.get():
            self.load_button.config(state="normal")
        else:
            self.load_button.config(state="disabled")

    # --- 加载与处理 ---
    def load_assets(self):
        try:
            self.status_label.config(text="正在加载模型...")
            self.root.update_idletasks()
            self.model = YOLO(self.model_path.get())
            self.class_names = list(self.model.names.values())

            self.cap = cv2.VideoCapture(self.video_path.get())
            if not self.cap.isOpened():
                raise Exception("无法打开视频文件")

            os.makedirs(self.output_dir.get(), exist_ok=True)

            # 启用导航和操作按钮
            self.next_btn.config(state="normal")
            self.skip_btn.config(state="normal")
            self.add_box_btn.config(state="normal")
            self.repredict_btn.config(state="normal")
            self.clear_btn.config(state="normal")

            self.status_label.config(text="加载成功，请点击'下一张'开始处理。")
            self.navigate_frames(1, save=False)  # 自动加载第一帧

        except Exception as e:
            messagebox.showerror("加载失败", f"加载资源时出错: {e}")

    def re_predict_frame(self):
        if self.current_frame_img is None:
            messagebox.showwarning("无图像", "没有加载当前帧的图像，无法重新预测。")
            return

        # 保存当前UI上的配置
        self.save_config()
        self.process_and_display_frame(self.current_frame_img, self.current_frame_num, predict=True)

    def process_and_display_frame(self, frame, frame_num, predict=True):
        self.current_frame_img = frame.copy()

        # 显示原图
        self.display_image(self.current_frame_img, self.orig_canvas)

        # 显示检测图 (背景)
        self.display_image(self.current_frame_img, self.detect_canvas)

        if predict:
            # YOLO 检测
            results = self.model.predict(self.current_frame_img, imgsz=self.img_size.get(),
                                         conf=self.conf_threshold.get(), verbose=False)
            boxes = results[0].boxes.data.cpu().numpy() if results[0].boxes is not None else []
            self.detections = []
            for i, box in enumerate(boxes):
                x1, y1, x2, y2, conf, cls = box
                self.detections.append({
                    "id": i, "label": self.model.names[int(cls)],
                    "coords": [x1, y1, x2, y2], "conf": conf, "canvas_id": None
                })

        self.redraw_detections()
        self.update_detection_list()
        self.update_status()

    def redraw_detections(self):
        # 清除旧的框
        self.detect_canvas.delete("detection")
        for det in self.detections:
            x1, y1, x2, y2 = det["coords"]
            color = "cyan" if det["id"] == self.selected_detection_id else "red"
            canvas_id = self.detect_canvas.create_rectangle(
                x1, y1, x2, y2, outline=color, width=2, tags=("detection", f"det_{det['id']}"))
            self.detect_canvas.create_text(
                x1, y1 - 10, text=f"{det['label']} ({det['conf']:.2f})", fill=color, anchor="nw",
                tags=("detection", f"text_{det['id']}"))
            det["canvas_id"] = canvas_id

    # --- 导航 ---
    def navigate_frames(self, direction, save=True):
        if save and self.history:
            self.save_annotations()

        if direction == 1:  # 下一张
            last_frame = self.history[-1] if self.history else -self.frame_interval.get()
            target_frame_num = last_frame + self.frame_interval.get()
            predict = True
        elif direction == -1:  # 上一张
            if len(self.history) < 2: return
            self.history.pop()
            target_frame_num = self.history[-1]
            predict = False  # 返回时不重新预测，而是加载已有标注
        else:
            return

        total_frames = int(self.cap.get(cv2.CAP_PROP_FRAME_COUNT))
        if target_frame_num >= total_frames:
            self.status_label.config(text="视频处理结束！")
            return

        self.cap.set(cv2.CAP_PROP_POS_FRAMES, target_frame_num)
        ret, frame = self.cap.read()
        if not ret:
            self.status_label.config(text="视频读取完毕！")
            return

        self.current_frame_num = target_frame_num
        if direction == 1:
            self.history.append(self.current_frame_num)

        # 尝试加载已有的json文件
        json_path = os.path.join(self.output_dir.get(), f"frame_{self.current_frame_num}.json")
        if os.path.exists(json_path):
            self.load_annotations(json_path)
            predict = False

        self.process_and_display_frame(frame, self.current_frame_num, predict=predict)
        self.prev_btn.config(state="normal" if len(self.history) > 1 else "disabled")

    # --- 标注文件操作 ---
    def save_annotations(self):
        # 保存前再次更新配置，确保UI上的修改被写入
        self.save_config()

        if not self.detections:
            # 如果没有检测框，检查是否存在旧文件并删除
            json_path = os.path.join(self.output_dir.get(), f"frame_{self.current_frame_num}.json")
            if os.path.exists(json_path):
                os.remove(json_path)
            return

        h, w, _ = self.current_frame_img.shape
        img_name = f"frame_{self.current_frame_num}.jpg"
        json_name = f"frame_{self.current_frame_num}.json"

        cv2.imwrite(os.path.join(self.output_dir.get(), img_name), self.current_frame_img)

        labelme_shapes = []
        for det in self.detections:
            x1, y1, x2, y2 = det["coords"]
            labelme_shapes.append({
                "label": det["label"],
                "points": [[float(x1), float(y1)], [float(x2), float(y2)]],
                "group_id": None, "shape_type": "rectangle", "flags": {}
            })

        with open(os.path.join(self.output_dir.get(), json_name), "w", encoding="utf-8") as f:
            json.dump({
                "version": "5.3.1", "flags": {}, "shapes": labelme_shapes,
                "imagePath": img_name, "imageData": None, "imageHeight": h, "imageWidth": w
            }, f, indent=2)

    def load_annotations(self, json_path):
        with open(json_path, 'r', encoding='utf-8') as f:
            data = json.load(f)
        self.detections = []
        for i, shape in enumerate(data['shapes']):
            x1, y1 = shape['points'][0]
            x2, y2 = shape['points'][1]
            self.detections.append({
                "id": i, "label": shape['label'],
                "coords": [min(x1, x2), min(y1, y2), max(x1, x2), max(y1, y2)],
                "conf": 1.0, "canvas_id": None  # 手动加载的标注置信度设为1.0
            })

    # --- 画布交互 ---
    def on_press(self, event):
        self.selected_detection_id = None
        if self.add_box_mode:
            self.drawing = True
            self.new_box_start_pos = (event.x, event.y)
            self.temp_box_id = self.detect_canvas.create_rectangle(
                event.x, event.y, event.x, event.y, outline="green", width=2, dash=(4, 4))
        else:
            # 查找点击位置的item
            item = self.get_item_at_cursor(event)
            if item:
                self.selected_detection_id = item["id"]
                self.start_pos = (event.x, event.y)
                self.start_coords = item["coords"]

        self.redraw_detections()
        self.update_detection_list()

    def on_right_press(self, event):
        item = self.get_item_at_cursor(event)
        if item:
            chosen_class = self.ask_class_choice()
            if chosen_class:
                item['label'] = chosen_class
                self.redraw_detections()
                self.update_detection_list()

    def on_drag(self, event):
        if self.drawing and self.add_box_mode:
            self.detect_canvas.coords(self.temp_box_id, self.new_box_start_pos[0], self.new_box_start_pos[1], event.x,
                                      event.y)
        elif self.selected_detection_id is not None:
            dx = event.x - self.start_pos[0]
            dy = event.y - self.start_pos[1]
            x1, y1, x2, y2 = self.start_coords
            new_coords = [x1 + dx, y1 + dy, x2 + dx, y2 + dy]

            det = next((d for d in self.detections if d["id"] == self.selected_detection_id), None)
            if det:
                det["coords"] = new_coords
                self.redraw_detections()

    def on_release(self, event):
        if self.drawing and self.add_box_mode:
            self.drawing = False
            self.detect_canvas.delete(self.temp_box_id)
            end_pos = (event.x, event.y)

            chosen_class = self.ask_class_choice()
            if chosen_class:
                new_id = max([d['id'] for d in self.detections] + [-1]) + 1
                self.detections.append({
                    "id": new_id, "label": chosen_class,
                    "coords": [min(self.new_box_start_pos[0], end_pos[0]), min(self.new_box_start_pos[1], end_pos[1]),
                               max(self.new_box_start_pos[0], end_pos[0]), max(self.new_box_start_pos[1], end_pos[1])],
                    "conf": 1.0, "canvas_id": None
                })
            self.toggle_add_box_mode()
            self.redraw_detections()
            self.update_detection_list()

        self.selected_detection_id = None
        self.redraw_detections()

    def on_list_select(self, event):
        selection_indices = self.detection_list.curselection()
        if selection_indices:
            selected_index = selection_indices[0]
            self.selected_detection_id = self.detections[selected_index]["id"]
            self.redraw_detections()

    # --- 辅助功能 ---
    def get_item_at_cursor(self, event):
        items = self.detect_canvas.find_overlapping(event.x - 2, event.y - 2, event.x + 2, event.y + 2)
        if items:
            for item_id in reversed(items):
                tags = self.detect_canvas.gettags(item_id)
                if tags and "detection" in tags:
                    det_id = int(tags[1].split("_")[1])
                    return next((d for d in self.detections if d["id"] == det_id), None)
        return None

    def ask_class_choice(self):
        if not self.class_names:
            return simpledialog.askstring("输入类别", "请输入类别名称:")

        dialog = tk.Toplevel(self.root)
        dialog.title("选择类别")
        tk.Label(dialog, text="请为新的标注框选择一个类别:").pack(padx=20, pady=10)

        listbox = tk.Listbox(dialog)
        for name in self.class_names:
            listbox.insert(tk.END, name)
        listbox.pack(padx=20, pady=5)

        result = tk.StringVar()

        def on_ok():
            if listbox.curselection():
                result.set(self.class_names[listbox.curselection()[0]])
            dialog.destroy()

        ok_button = ttk.Button(dialog, text="确定", command=on_ok)
        ok_button.pack(pady=10)

        dialog.transient(self.root)
        dialog.grab_set()
        self.root.wait_window(dialog)

        return result.get()

    def toggle_add_box_mode(self):
        self.add_box_mode = not self.add_box_mode
        if self.add_box_mode:
            self.detect_canvas.config(cursor="plus")
            self.add_box_btn.config(text="取消添加")
        else:
            self.detect_canvas.config(cursor="crosshair")
            self.add_box_btn.config(text="添加新框")

    def cancel_add_mode(self, event=None):
        if self.add_box_mode:
            self.toggle_add_box_mode()

    def delete_selected(self, event=None):
        if self.selected_detection_id is not None:
            self.detections = [d for d in self.detections if d["id"] != self.selected_detection_id]
            self.selected_detection_id = None
            self.redraw_detections()
            self.update_detection_list()

    def clear_all_detections(self):
        if messagebox.askokcancel("确认", "确定要清除当前帧的所有标注吗?"):
            self.detections = []
            self.selected_detection_id = None
            self.redraw_detections()
            self.update_detection_list()

    def update_detection_list(self):
        self.detection_list.delete(0, tk.END)
        for i, det in enumerate(self.detections):
            self.detection_list.insert(tk.END, f"ID {det['id']}: {det['label']} ({det['conf']:.2f})")
            if det["id"] == self.selected_detection_id:
                self.detection_list.selection_set(i)

        self.delete_btn.config(state="normal" if self.selected_detection_id is not None else "disabled")

    def update_status(self):
        self.status_label.config(text=f"当前第 {self.current_frame_num} 帧 - 共检测到 {len(self.detections)} 个目标")

    def display_image(self, cv_img, canvas):
        canvas.delete("all")
        h, w, _ = cv_img.shape

        # 保持比例缩放图像以适应画布
        canvas_w, canvas_h = canvas.winfo_width(), canvas.winfo_height()
        if canvas_w < 10 or canvas_h < 10:  # 画布未完全渲染时给予默认值
            canvas_w, canvas_h = 600, 800

        scale = min(canvas_w / w, canvas_h / h)
        new_w, new_h = int(w * scale), int(h * scale)

        resized_img = cv2.resize(cv_img, (new_w, new_h))

        img_rgb = cv2.cvtColor(resized_img, cv2.COLOR_BGR2RGB)
        img_pil = Image.fromarray(img_rgb)

        # 必须将ImageTk对象保存为实例属性，否则会被垃圾回收
        imgtk = ImageTk.PhotoImage(img_pil)
        if canvas == self.orig_canvas:
            self.orig_imgtk = imgtk
        else:
            self.detect_imgtk = imgtk

        canvas.create_image(0, 0, anchor="nw", image=imgtk)
        canvas.config(scrollregion=canvas.bbox(tk.ALL))


if __name__ == '__main__':
    root = tk.Tk()
    app = YoloAnnotator(root)
    root.mainloop()

